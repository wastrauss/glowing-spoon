name: Sort and Validate Translation Files

on:
  push:
    paths:
      - "translations/**/*.yml"
      # Adjust these patterns to match your translation file locations:
      # - 'locales/**/*.yaml'
      # - 'i18n/**/*.yml'

permissions:
  contents: write        # Needed to commit changes
  issues: write          # Needed to open sync-review issues

jobs:
  sort-and-validate-translations:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install js-yaml
        run: |
          mkdir -p /tmp/node_modules
          npm install --prefix /tmp/node_modules js-yaml
      
      - name: Sync, Sort and Validate
        id: process-translations
        run: |
          export NODE_PATH=/tmp/node_modules/node_modules
          
          # Create a temporary file for validation results
          echo "" > /tmp/validation_results.txt
          
          node -e '
            const yaml = require("js-yaml");
            const fs = require("fs");
            const path = require("path");
            
            // --- CONFIGURATION ---
            const ENGLISH_FILE = "./translations/en_US.yml"; 
            const TRANSLATION_DIR = "./translations";
            // ---------------------

            // Helper: Recursively get all keys in dot notation (e.g., "auth.login.title")
            function getAllKeys(obj, prefix = "") {
              let keys = [];
              for (const key in obj) {
                const fullKey = prefix ? `${prefix}.${key}` : key;
                if (obj[key] !== null && typeof obj[key] === "object" && !Array.isArray(obj[key])) {
                  keys = keys.concat(getAllKeys(obj[key], fullKey));
                } else {
                  keys.push(fullKey);
                }
              }
              return keys;
            }

            // Helper: Get value from nested object using dot notation
            function getDeep(obj, path) {
              return path.split(".").reduce((acc, part) => acc && acc[part], obj);
            }

            // Helper: Set value in nested object using dot notation (Creates structure if missing)
            function setDeep(obj, path, value) {
              const parts = path.split(".");
              let current = obj;
              for (let i = 0; i < parts.length - 1; i++) {
                const part = parts[i];
                if (!current[part] || typeof current[part] !== "object") {
                  current[part] = {};
                }
                current = current[part];
              }
              current[parts[parts.length - 1]] = value;
            }

            // Helper: Recursively sort object keys
            function sortObject(obj) {
              if (Array.isArray(obj)) {
                return obj.map(sortObject);
              } else if (obj !== null && typeof obj === "object") {
                return Object.keys(obj)
                  .sort()
                  .reduce((sorted, key) => {
                    sorted[key] = sortObject(obj[key]);
                    return sorted;
                  }, {});
              }
              return obj;
            }

            try {
              if (!fs.existsSync(ENGLISH_FILE)) {
                console.error("‚ö†Ô∏è English file not found at:", ENGLISH_FILE);
                process.exit(1);
              }

              // 1. Load English Source
              const englishRaw = fs.readFileSync(ENGLISH_FILE, "utf8");
              // Extract header (comments at top) to preserve them
              const englishLines = englishRaw.split("\\n");
              let englishHeader = [];
              let idx = 0;
              while (idx < englishLines.length && (englishLines[idx].trim().startsWith("#") || englishLines[idx].trim() === "")) {
                englishHeader.push(englishLines[idx]);
                idx++;
              }
              const englishContent = yaml.load(englishLines.slice(idx).join("\\n"));
              const englishKeys = new Set(getAllKeys(englishContent));
              console.log(`üìã English Source: ${englishKeys.size} keys found.`);

              // 2. Process other files
              const files = fs.readdirSync(TRANSLATION_DIR)
                .filter(f => (f.endsWith(".yml") || f.endsWith(".yaml")) && f !== path.basename(ENGLISH_FILE))
                .map(f => path.join(TRANSLATION_DIR, f));

              let hasIssues = false;
              let report = "# Translation Validation Report\\n\\n";

              for (const file of files) {
                const langCode = path.basename(file, path.extname(file));
                const fileRaw = fs.readFileSync(file, "utf8");
                
                // Preserve Language File Header
                const fileLines = fileRaw.split("\\n");
                let fileHeader = [];
                let fIdx = 0;
                while (fIdx < fileLines.length && (fileLines[fIdx].trim().startsWith("#") || fileLines[fIdx].trim() === "")) {
                  fileHeader.push(fileLines[fIdx]);
                  fIdx++;
                }
                
                let content = yaml.load(fileLines.slice(fIdx).join("\\n")) || {};
                const langKeys = new Set(getAllKeys(content));

                // A. Sync Missing Keys (English -> Lang)
                const missingKeys = [...englishKeys].filter(k => !langKeys.has(k));
                if (missingKeys.length > 0) {
                  console.log(`üîß ${langCode}: Propagating ${missingKeys.length} missing keys from English...`);
                  missingKeys.forEach(key => {
                    const engValue = getDeep(englishContent, key);
                    setDeep(content, key, engValue);
                  });
                } else {
                  console.log(`‚úÖ ${langCode}: No missing keys.`);
                }

                // B. Detect Extra Keys (Lang -> ??)
                const extraKeys = [...langKeys].filter(k => !englishKeys.has(k));
                if (extraKeys.length > 0) {
                  hasIssues = true;
                  report += `## ‚ö†Ô∏è ${langCode}\\n`;
                  report += `**${extraKeys.length} keys** exist in this file but are missing from English (deprecated?):\\n`;
                  extraKeys.forEach(k => report += `- \`${k}\`\\n`);
                  report += "\\n";
                  console.log(`‚ùå ${langCode}: ${extraKeys.length} extra keys found.`);
                }

                // C. Sort and Save
                // Always sort and save to ensure consistency, even if no keys added
                const sortedContent = sortObject(content);
                
                let output = yaml.dump(sortedContent, {
                  indent: 2,
                  lineWidth: -1,
                  noRefs: true,
                  quotingType: "\"",
                  forceQuotes: true
                });

                // Fix unicode formatting if needed
                output = output.replace(/\\\\u([0-9A-Fa-f]{4})/g, (_, code) => String.fromCharCode(parseInt(code, 16)));
                output = output.replace(/\\\\_/g, "\\u00A0");

                const finalOutput = fileHeader.join("\\n") + (fileHeader.length > 0 ? "\\n" : "") + output;
                fs.writeFileSync(file, finalOutput);
              }

              if (hasIssues) {
                fs.writeFileSync("/tmp/validation_results.txt", report);
                fs.writeFileSync("/tmp/has_validation_issues.txt", "true");
              }

            } catch (e) {
              console.error("Fatal Error:", e);
              process.exit(1);
            }
          '
      
      - name: Check for changes
        id: git-check
        run: |
          git diff --exit-code || echo "changes=true" >> $GITHUB_OUTPUT
      
      - name: Commit and push if changed
        if: steps.git-check.outputs.changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add -A
          git commit -m "chore: sync translations with English and sort keys"
          
          # Explicitly set the remote URL to include the token
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}
          git push
      
      - name: Check validation results
        id: check-validation
        run: |
          if [ -f "/tmp/has_validation_issues.txt" ]; then
            echo "validation_failed=true" >> $GITHUB_OUTPUT
            # We exit 0 here so the pipeline stays green, but we create an issue below.
            # Change to exit 1 if you want the pipeline to fail on extra keys.
            exit 0 
          fi
      
      - name: Create issue for translation mismatches
        if: steps.check-validation.outputs.validation_failed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let body = 'Translation validation has detected **extra keys** in language files that are not present in the English source.\\n\\n';
            
            if (fs.existsSync('/tmp/validation_results.txt')) {
              body += fs.readFileSync('/tmp/validation_results.txt', 'utf8');
            }
            
            body += '\n\n---\n**Action required:** Review these keys. If they are obsolete, remove them from the translation files.';
            body += `\nCommit: ${context.sha}`;
            
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'translation-sync'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '‚ö†Ô∏è Translation Keys Review Needed',
                body: body,
                labels: ['translation-sync', 'needs-review']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `## New validation run\n\n${body}`
              });
            }