name: Sort and Validate Translation Files

on:
  push:
    paths:
      - "translations/**/*.yml"
      # - 'locales/**/*.yaml' # Add your paths here

permissions:
  contents: write        # Needed to commit changes
  issues: write          # Needed to open sync-review issues

jobs:
  sort-and-validate-translations:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install js-yaml
        run: |
          mkdir -p /tmp/node_modules
          npm install --prefix /tmp/node_modules js-yaml
      
      - name: Process Translations
        id: process-translations
        run: |
          export NODE_PATH=/tmp/node_modules/node_modules
          
          # Initialize validation report
          echo "" > /tmp/validation_results.txt
          
          node -e '
            const yaml = require("js-yaml");
            const fs = require("fs");
            const path = require("path");
            
            // --- CONFIGURATION ---
            const ENGLISH_FILE = "./translations/en_US.yml"; 
            const TRANSLATION_DIR = "./translations";
            // ---------------------

            // 1. HELPER FUNCTIONS
            
            // Get all keys recursively in dot notation (e.g. "home.header.title")
            function getAllKeys(obj, prefix = "") {
              let keys = [];
              for (const key in obj) {
                const fullKey = prefix ? `${prefix}.${key}` : key;
                if (obj[key] !== null && typeof obj[key] === "object" && !Array.isArray(obj[key])) {
                  keys = keys.concat(getAllKeys(obj[key], fullKey));
                } else {
                  keys.push(fullKey);
                }
              }
              return keys;
            }

            // Get value from dot notation string
            function getDeep(obj, path) {
              return path.split(".").reduce((acc, part) => acc && acc[part], obj);
            }

            // Set value into object using dot notation (Creating structure if needed)
            function setDeep(obj, path, value) {
              const parts = path.split(".");
              let current = obj;
              for (let i = 0; i < parts.length - 1; i++) {
                const part = parts[i];
                if (!current[part] || typeof current[part] !== "object") {
                  current[part] = {};
                }
                current = current[part];
              }
              current[parts[parts.length - 1]] = value;
            }

            // Recursive alphabetical sort
            function sortObject(obj) {
              if (Array.isArray(obj)) {
                return obj.map(sortObject);
              } else if (obj !== null && typeof obj === "object") {
                return Object.keys(obj)
                  .sort()
                  .reduce((sorted, key) => {
                    sorted[key] = sortObject(obj[key]);
                    return sorted;
                  }, {});
              }
              return obj;
            }

            // Helper to write YAML while preserving top-level comments (Header)
            function writeYaml(filePath, content, originalLines) {
              // Extract comments from the top of the original file
              let header = [];
              let idx = 0;
              while (idx < originalLines.length && (originalLines[idx].trim().startsWith("#") || originalLines[idx].trim() === "")) {
                header.push(originalLines[idx]);
                idx++;
              }
              
              const sorted = sortObject(content);
              
              let output = yaml.dump(sorted, {
                indent: 2,
                lineWidth: -1,
                noRefs: true,
                quotingType: "\"",
                forceQuotes: true
              });

              // Fix unicode escape sequences
              output = output.replace(/\\\\u([0-9A-Fa-f]{4})/g, (_, code) => String.fromCharCode(parseInt(code, 16)));
              output = output.replace(/\\\\_/g, "\\u00A0");

              const finalContent = header.join("\\n") + (header.length > 0 ? "\\n" : "") + output;
              fs.writeFileSync(filePath, finalContent);
            }

            try {
              if (!fs.existsSync(ENGLISH_FILE)) {
                console.error("‚ö†Ô∏è English file not found at:", ENGLISH_FILE);
                process.exit(1);
              }

              // --- PROCESS ENGLISH FILE FIRST (Source of Truth) ---
              console.log(`Processing Source: ${ENGLISH_FILE}`);
              const englishRaw = fs.readFileSync(ENGLISH_FILE, "utf8");
              // We load it to get the object
              // We split lines to preserve the header later
              const englishLines = englishRaw.split("\\n");
              
              // Find where YAML actually starts to parse it
              let engIdx = 0;
              while (engIdx < englishLines.length && (englishLines[engIdx].trim().startsWith("#") || englishLines[engIdx].trim() === "")) {
                engIdx++;
              }
              
              const englishContent = yaml.load(englishLines.slice(engIdx).join("\\n")) || {};
              const englishKeys = new Set(getAllKeys(englishContent));
              console.log(`üìã English keys: ${englishKeys.size}`);

              // Requirement 1: Sort and Save English file immediately
              writeYaml(ENGLISH_FILE, englishContent, englishLines);


              // --- PROCESS OTHER FILES ---
              const files = fs.readdirSync(TRANSLATION_DIR)
                .filter(f => (f.endsWith(".yml") || f.endsWith(".yaml")) && f !== path.basename(ENGLISH_FILE))
                .map(f => path.join(TRANSLATION_DIR, f));

              let hasIssues = false;
              let report = "# Translation Validation Report\\n\\n";

              for (const file of files) {
                const langCode = path.basename(file, path.extname(file));
                const fileRaw = fs.readFileSync(file, "utf8");
                const fileLines = fileRaw.split("\\n");
                
                // Parse existing content
                let fIdx = 0;
                while (fIdx < fileLines.length && (fileLines[fIdx].trim().startsWith("#") || fileLines[fIdx].trim() === "")) {
                  fIdx++;
                }
                const content = yaml.load(fileLines.slice(fIdx).join("\\n")) || {};
                const langKeys = new Set(getAllKeys(content));

                // Requirement 2: Add missing English keys (Sync)
                const missingKeys = [...englishKeys].filter(k => !langKeys.has(k));
                
                if (missingKeys.length > 0) {
                  console.log(`üîß ${langCode}: Adding ${missingKeys.length} missing keys from English`);
                  missingKeys.forEach(key => {
                    const engValue = getDeep(englishContent, key);
                    setDeep(content, key, engValue);
                  });
                } else {
                  console.log(`‚úÖ ${langCode}: No missing keys`);
                }

                // Requirement 3: Check for Extra keys (Issue reporting)
                const extraKeys = [...langKeys].filter(k => !englishKeys.has(k));
                if (extraKeys.length > 0) {
                  hasIssues = true;
                  report += `## ‚ö†Ô∏è ${langCode}\\n`;
                  report += `**${extraKeys.length} extra keys** (present in ${langCode} but missing in English):\\n`;
                  extraKeys.forEach(k => report += `- \`${k}\`\\n`);
                  report += "\\n";
                  console.log(`‚ùå ${langCode}: ${extraKeys.length} extra keys detected`);
                }

                // Requirement 1: Sort and Save Language file
                writeYaml(file, content, fileLines);
              }

              if (hasIssues) {
                fs.writeFileSync("/tmp/validation_results.txt", report);
                fs.writeFileSync("/tmp/has_validation_issues.txt", "true");
              }

            } catch (e) {
              console.error("Fatal Script Error:", e);
              process.exit(1);
            }
          '
      
      - name: Check for changes
        id: git-check
        run: |
          git diff --exit-code || echo "changes=true" >> $GITHUB_OUTPUT
      
      - name: Commit and push if changed
        if: steps.git-check.outputs.changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add -A
          git commit -m "chore: sort translation files and sync missing keys from English"
          
          # FIX: Explicitly set the remote using the token to avoid authentication errors
          git remote set-url origin https://x-access-token:${GITHUB_TOKEN}@github.com/${{ github.repository }}
          git push
      
      - name: Check validation results
        id: check-validation
        run: |
          if [ -f "/tmp/has_validation_issues.txt" ]; then
            echo "validation_failed=true" >> $GITHUB_OUTPUT
          fi
      
      - name: Create issue for extra keys
        if: steps.check-validation.outputs.validation_failed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            let body = 'The translation workflow detected keys in language files that **do not exist** in the English source.\\n\\n';
            
            if (fs.existsSync('/tmp/validation_results.txt')) {
              body += fs.readFileSync('/tmp/validation_results.txt', 'utf8');
            }
            
            body += '\n\n---\n**Action required:**\\n1. Check if these keys are obsolete and should be deleted.\\n2. Or check if they are new features missing from the English source.';
            body += `\n\nCommit: ${context.sha}`;
            
            // Search for existing open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'translation-sync'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '‚ö†Ô∏è Extra Translation Keys Detected',
                body: body,
                labels: ['translation-sync', 'needs-review']
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `## New validation run\n\n${body}`
              });
            }