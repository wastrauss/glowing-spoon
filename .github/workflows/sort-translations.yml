name: Sort and Validate Translation Files

on:
  push:
    paths:
      - "translations/**/*.yml"
      # Adjust these patterns to match your translation file locations:
      # - 'translations/**/*.yml'
      # - 'locales/**/*.yaml'
      # - 'i18n/**/*.yml'

permissions:
  contents: write        # Needed to commit changes
  issues: write          # Needed to open sync-review issues

jobs:
  sort-and-validate-translations:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install js-yaml
        run: |
          mkdir -p /tmp/node_modules
          npm install --prefix /tmp/node_modules js-yaml
      
      - name: Sort and validate translation files
        id: process-translations
        run: |
          export NODE_PATH=/tmp/node_modules/node_modules
          
          # Create a temporary file for validation results
          echo "" > /tmp/validation_results.txt
          
          # Find all YAML translation files
          find "./translations" \( -name "*.yml" -o -name "*.yaml" \) -type f | while read file; do
            # Skip workflow files and node_modules
            if [[ "$file" == *".github/workflows"* ]] || \
               [[ "$file" == *"node_modules"* ]]; then
              continue
            fi
            
            echo "Processing $file"
            
            # Sort the YAML file
            node -e "
              const yaml = require('js-yaml');
              const fs = require('fs');
              const file = process.argv[1];
              
              try {
                const content = fs.readFileSync(file, 'utf8');
                const data = yaml.load(content);
                
                // Recursive function to sort nested objects
                function sortObject(obj) {
                  if (Array.isArray(obj)) {
                    return obj.map(sortObject);
                  } else if (obj !== null && typeof obj === 'object') {
                    return Object.keys(obj)
                      .sort()
                      .reduce((sorted, key) => {
                        sorted[key] = sortObject(obj[key]);
                        return sorted;
                      }, {});
                  }
                  return obj;
                }
                
                const sorted = sortObject(data);
                
                // Convert back to YAML with proper formatting
                const output = yaml.dump(sorted, {
                  indent: 2,
                  lineWidth: -1,
                  noRefs: true,
                  quotingType: '\"',
                  forceQuotes: false
                });
                
                fs.writeFileSync(file, output);
                console.log('‚úì Sorted successfully');
              } catch (e) {
                console.log('‚úó Error:', e.message);
              }
            " "$file"
          done
          
          # Now validate and sync translations against English
          node -e '
            const yaml = require("js-yaml");
            const fs = require("fs");
            const path = require("path");
            
            // Configure these paths to match your setup
            const ENGLISH_FILE = "./translations/en_US.yml"; // Adjust this path
            const TRANSLATION_DIR = "./translations"; // Adjust this path
            
            function getAllKeys(obj, prefix = "") {
              let keys = [];
              for (const key in obj) {
                const fullKey = prefix ? `${prefix}.${key}` : key;
                if (obj[key] !== null && typeof obj[key] === "object" && !Array.isArray(obj[key])) {
                  keys = keys.concat(getAllKeys(obj[key], fullKey));
                } else {
                  keys.push(fullKey);
                }
              }
              return keys;
            }
            
            function getValueByPath(obj, path) {
              return path.split(".").reduce((curr, key) => curr?.[key], obj);
            }
            
            function setValueByPath(obj, path, value) {
              const keys = path.split(".");
              const lastKey = keys.pop();
              const target = keys.reduce((curr, key) => {
                if (!curr[key]) curr[key] = {};
                return curr[key];
              }, obj);
              target[lastKey] = value;
            }
            
            try {
              // Check if English file exists
              if (!fs.existsSync(ENGLISH_FILE)) {
                console.log("‚ö†Ô∏è  English translation file not found at:", ENGLISH_FILE);
                console.log("Please update ENGLISH_FILE path in the workflow.");
                process.exit(0);
              }
              
              const englishContent = yaml.load(fs.readFileSync(ENGLISH_FILE, "utf8"));
              const englishKeys = new Set(getAllKeys(englishContent));
              
              console.log(`üìã English file has ${englishKeys.size} keys`);
              
              // Find all translation files
              const files = fs.readdirSync(TRANSLATION_DIR)
                .filter(f => (f.endsWith(".yml") || f.endsWith(".yaml")) && f !== path.basename(ENGLISH_FILE))
                .map(f => path.join(TRANSLATION_DIR, f));
              
              let hasIssues = false;
              let hasAutoFixes = false;
              let report = "# Translation Validation Report\n\n";
              
              for (const file of files) {
                const langCode = path.basename(file, path.extname(file));
                const content = yaml.load(fs.readFileSync(file, "utf8"));
                const langKeys = new Set(getAllKeys(content));
                
                // Find keys in language file but not in English
                const extraKeys = [...langKeys].filter(k => !englishKeys.has(k));
                
                // Find keys in English but not in language file - AUTO-FIX these
                const missingKeys = [...englishKeys].filter(k => !langKeys.has(k));
                
                if (missingKeys.length > 0) {
                  hasAutoFixes = true;
                  console.log(`üîß ${langCode}: Adding ${missingKeys.length} missing keys from English`);
                  
                  // Add missing keys with English values
                  missingKeys.forEach(key => {
                    const englishValue = getValueByPath(englishContent, key);
                    setValueByPath(content, key, englishValue);
                  });
                  
                  // Sort the content before saving
                  function sortObject(obj) {
                    if (Array.isArray(obj)) {
                      return obj.map(sortObject);
                    } else if (obj !== null && typeof obj === "object") {
                      return Object.keys(obj)
                        .sort()
                        .reduce((sorted, key) => {
                          sorted[key] = sortObject(obj[key]);
                          return sorted;
                        }, {});
                    }
                    return obj;
                  }
                  
                  const sorted = sortObject(content);
                  const output = yaml.dump(sorted, {
                    indent: 2,
                    lineWidth: -1,
                    noRefs: true,
                    quotingType: "\"",
                    forceQuotes: false
                  });
                  
                  fs.writeFileSync(file, output);
                }
                
                if (extraKeys.length > 0) {
                  hasIssues = true;
                  report += `## ‚ö†Ô∏è  ${langCode}\n\n`;
                  report += `### Keys requiring review (present in ${langCode} but missing from English):\n`;
                  report += `These keys exist in the ${langCode} translation but not in the English reference file. `;
                  report += `Please review whether these should be added to English or removed from ${langCode}.\n\n`;
                  extraKeys.forEach(k => report += `- \`${k}\`\n`);
                  report += "\n";
                  
                  console.log(`‚ùå ${langCode}: ${extraKeys.length} extra keys need review`);
                } else if (missingKeys.length === 0) {
                  console.log(`‚úÖ ${langCode}: All keys match English`);
                }
              }
              
              if (hasAutoFixes) {
                console.log("\n‚úÖ Missing keys auto-filled with English values");
              }
              
              if (hasIssues) {
                fs.writeFileSync("/tmp/validation_results.txt", report);
                console.log("\n‚ö†Ô∏è  Translation validation issues found!");
                // Write a flag file instead of exiting immediately
                fs.writeFileSync("/tmp/has_validation_issues.txt", "true");
              } else {
                console.log("\n‚úÖ All translations are in sync!");
              }
              
            } catch (e) {
              console.log("Error during validation:", e.message);
              process.exit(0);
            }
          '
      
      - name: Check for changes
        id: git-check
        run: |
          git diff --exit-code || echo "changes=true" >> $GITHUB_OUTPUT
      
      - name: Commit and push if changed
        if: steps.git-check.outputs.changes == 'true'
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add -A
          git commit -m "chore: sort translation files and sync missing keys from English"
          git push
      
      - name: Check validation results
        id: check-validation
        run: |
          if [ -f "/tmp/has_validation_issues.txt" ]; then
            echo "validation_failed=true" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Create issue for translation mismatches
        if: failure() && steps.check-validation.outputs.validation_failed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read validation results
            let body = 'Translation validation has detected key mismatches between language files and the English reference file.\n\n';
            
            if (fs.existsSync('/tmp/validation_results.txt')) {
              body += fs.readFileSync('/tmp/validation_results.txt', 'utf8');
            }
            
            body += '\n\n---\n**Action required:** Please review and sync the translation files.\n';
            body += `Commit: ${context.sha}\n`;
            body += `Triggered by: @${context.actor}`;
            
            // Check if there's already an open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'translation-sync'
            });
            
            if (issues.data.length === 0) {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: '‚ö†Ô∏è Translation Keys Out of Sync',
                body: body,
                labels: ['translation-sync', 'needs-review']
              });
            } else {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `## New validation run\n\n${body}`
              });
            }